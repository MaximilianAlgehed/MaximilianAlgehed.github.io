<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>A Very Small SAT Solver</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">A Very Small SAT Solver</h1>
</header>
<p>For those who don’t know, my co-supervisor (yes, that is the person who does the opposite of a supervisor) is Koen Claessen. Koen is important to me, he is the man who got me into research by picking me up in the second year of my B.Sc. at Chalmers. Actually, Ramona Enache also deserves a special thanks for her involvement in that. Anyway, that’s a story for a different time. Back to the topic of this post. For those who don’t know him, Koen likes SAT. Koen likes SAT <em>a lot</em>. So to honour Koen I’m going to show you how to build a truly tiny SAT solver in Haskell.</p>
<p>We are going to go through a few iterations of our design, gradually refining it to eventually end up with a one line 97 character marvel of an incomprehensible program. All the code for this blogpost is available <a href="../blogposts/SAT">here</a>.</p>
<p>We begin by trying to understand the problem. In SAT we are given a propositional logic formula in Conjunctive Normal Form (CNF). CNF simply means that the formula is a <em>conjunction of disjunctions</em>. As an example, below is a CNF with variables <span class="math inline"><em>x</em><sub>1</sub></span>, <span class="math inline"><em>x</em><sub>2</sub></span>, and <span class="math inline"><em>x</em><sub>3</sub></span>. <br /><span class="math display">(<em>x</em><sub>1</sub> ∨ <em>x</em><sub>2</sub>) ∧ (¬<em>x</em><sub>2</sub> ∨ <em>x</em><sub>3</sub>)</span><br /> We are asked to find an assignment to the variables of the formula which make the formula true. In the example above one such assignment is <br /><span class="math display"><em>x</em><sub>1</sub> = ⊤, <em>x</em><sub>2</sub> = ⊥, <em>x</em><sub>3</sub> = ⊤</span><br /> Where <span class="math inline">⊤</span> denotes <code>True</code> and <span class="math inline">⊥</span> <code>False</code>. If there is no such assignment, as is the case for the formula <span class="math inline"><em>x</em><sub>1</sub> ∧ ¬<em>x</em><sub>1</sub></span>, we are asked to return <code>UNSAT</code>.</p>
<p>With an intuition for the problem formed we are ready to start to tackle the problem in Haskell. We start with some definitions. A Literal is either a variable, a positive Literal, or the negation of a variable, a negative Literal. One way to represent this in Haskell is with a fancy sum type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Variable</span> <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Literal</span>  <span class="fu">=</span> <span class="dt">Positive</span> <span class="dt">Variable</span> <span class="fu">|</span> <span class="dt">Negative</span> <span class="dt">Variable</span></a></code></pre></div>
<p>However, we are going to go for something slightly simpler:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Literal</span> <span class="fu">=</span> <span class="dt">Int</span></a></code></pre></div>
<p>Where a positive integer <code>x</code> represents a positive Literal and <code>-x</code> the negation of the Literal. We dissallow <code>0</code> as a Literal. A Clause is a disjunction of Literals, we represent this simply as a list of <code>Literal</code>s:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Clause</span> <span class="fu">=</span> [<span class="dt">Literal</span>]</a></code></pre></div>
<p>Similarly, a Problem is a conjunction of Clauses, represented as a list of Clauses:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Problem</span> <span class="fu">=</span> [<span class="dt">Clause</span>]</a></code></pre></div>
<p>Using this representation the Problem above can be coded as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">example ::</span> <span class="dt">Problem</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">example <span class="fu">=</span> [[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="fu">-</span><span class="dv">2</span>, <span class="dv">3</span>]]</a></code></pre></div>
<p>With our encoding of problems complete we move on to solutions. A solution to the SAT problem is an Assignment of variables to truth values. Alternatively, we can think of an Assignment as a list of true literals, with the constraint that the same variable appears at most once in the list.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Assignment</span> <span class="fu">=</span> [<span class="dt">Literal</span>]</a></code></pre></div>
<p>Our solution to SAT is going to involve a simple search procedure, we pick a literal and check if it should be true or false. We do this by propagating the choice of the value of a literal to the rest of the problem, reducing the problem to a simpler one:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">propagate ::</span> <span class="dt">Literal</span> <span class="ot">-&gt;</span> <span class="dt">Problem</span> <span class="ot">-&gt;</span> <span class="dt">Problem</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">propagate l p <span class="fu">=</span> [ filter (<span class="fu">/=</span> negate l) c <span class="fu">|</span> c <span class="ot">&lt;-</span> p, l <span class="ot">`notElem`</span> c ]</a></code></pre></div>
<p>With all preliminaries in place we can finally move on to building our first SAT solver:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">solve ::</span> <span class="dt">Problem</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Assignment</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">solve []        <span class="fu">=</span> <span class="dt">Just</span> []</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">solve ([]<span class="fu">:</span>p)    <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">solve ((l<span class="fu">:</span>c)<span class="fu">:</span>p) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="kw">case</span> solve (propagate l p) <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    <span class="dt">Just</span> assignment <span class="ot">-&gt;</span> <span class="dt">Just</span> (l<span class="fu">:</span>assignment)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="dt">Nothing</span>         <span class="ot">-&gt;</span> <span class="kw">case</span> solve (propagate (negate l) (c<span class="fu">:</span>p)) <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      <span class="dt">Just</span> assignment <span class="ot">-&gt;</span> <span class="dt">Just</span> (negate l<span class="fu">:</span>assignment)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      <span class="dt">Nothing</span>         <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>The type of <code>solve</code> tells us that it will take a problem and either return <code>Just</code> a satisftying assignment, or it will return <code>Nothing</code>, indicating that the problem is <code>UNSAT</code>. The implementation is just a simple backtracking search where we propagate the choice of the literal to the rest of the problem and check if the smaller problem has a solution or not and act accordingly.</p>
<p>If we run our solver on the problem from eariler we get the following solution:</p>
<pre class="shell"><code>ghci&gt; solve example
Just [1,-2]</code></pre>
<h2 id="multiple-solutions">Multiple Solutions</h2>
<p>With our initial solver completed we are ready to start golfing. The first thing we are goign to do is to make our solver slightly more powerfull. Instead of having it spit out only the first solution it finds, we are going to make it enumerate solutions. The new type of <code>solve</code> is the following:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">solve ::</span> <span class="dt">Problem</span> <span class="ot">-&gt;</span> [<span class="dt">Assignment</span>]</a></code></pre></div>
<p>Instead of returning a <code>Maybe Assignment</code> we now return a list of Assignments, where <code>[]</code> represents <code>UNSAT</code>. The first two cases are straightforward:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">solve [] <span class="fu">=</span> [[]]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">solve ([]<span class="fu">:</span>p) <span class="fu">=</span> []</a></code></pre></div>
<p>We simply replace <code>Just []</code> with <code>[[]]</code> and <code>Nothing</code> with <code>[]</code>. The case which actually does the solving is also relatively straightforward:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">solve ((l<span class="fu">:</span>c)<span class="fu">:</span>p) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">     [ l<span class="fu">:</span>assignment        <span class="fu">|</span> assignment <span class="ot">&lt;-</span> solve (propagate l p) ]</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="fu">++</span> [ negate l<span class="fu">:</span>assignment <span class="fu">|</span> assignment <span class="ot">&lt;-</span> solve (propagate (negate l) (c<span class="fu">:</span>p)) ]</a></code></pre></div>
<p>We simply concatenate all the solutions we get from considering both <code>l</code> and <code>negate l</code>.</p>
<p>If we run this solver on the example from above we get the following:</p>
<pre class="shell"><code>ghci&gt; solve example
[[1,-2],[1,2],[-1,-2],[-1,2]]</code></pre>
</body>
</html>
